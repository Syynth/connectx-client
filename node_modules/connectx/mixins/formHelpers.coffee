email = require 'regex-email'
{NotificationActionCreators} = require 'connectx/actions'

getLabel = (reqs, defaultName) ->
  if reqs.label
    reqs.label
  else
    defaultName

getPatternError = (input, pattern) ->
  switch pattern
    when 'email'
      unless email.test input
        'is not a valid email'
    else
      undefined

getData = (self) ->
  data = {}
  for fieldName, reqs of self.formFields
    # TODO: Support things other than text fields (i.e. checkboxes, etc)
    data[fieldName] = self.refs[fieldName].getDOMNode().value.trim()
  return data

module.exports =
  validateSingle: (name) ->
    data = getData @
    reqs = @formFields[name]
    if reqs.required and data[name].length is 0
      return "#{getLabel reqs, name} is required"
    else if reqs.pattern
      err = getPatternError data[name], reqs.pattern
      return "#{data[name]} #{err}" if err
    else if reqs.equalTo and not data[reqs.equalTo] is data[name]
        return "#{getLabel reqs, name} must match #{getLabel @formFields[reqs.equalTo], reqs.equalTo}"
    else if reqs.length and not data[name].length is reqs.length
        return "#{getLabel reqs, name} must be #{reqs.length} characters"
    else if reqs.match
      unless reqs.match.test data[name]
        return "#{getLabel reqs, name} is invalid"
    return null

  validate: ->
    data = getData @
    errors = []
    for fieldName, reqs of @formFields
      error = @validateSingle fieldName
      if error
        unless reqs.message
          errors.push error
        else
          errors.push reqs.message
    if errors.length > 0
      NotificationActionCreators.postErrors errors
      return false
    return true
  serializeForm: ->
    res = getData @
    for field, data of @formFields when data.transient
      delete res[field]
    return res
  clearForm: ->
    res = {}
    for field, data of @formFields
      res[field] = ''
    @setState res
