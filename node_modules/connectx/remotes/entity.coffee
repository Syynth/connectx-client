req = require 'superagent'
{ApiUrl} = require 'connectx/config'
{stubs, token} = require './helpers'
_ = require 'lodash'
guid = require 'guid'
Q = require 'q'

module.exports =

  createEntity: (type, data, cb) ->
    deferred = Q.defer()

    req.post "#{ApiUrl}/entity/#{type}"
      .withCredentials()
      .set 'CONNECTX-AUTH', token()
      .send data
      .end (err, res) ->
        # replace err with res.body.message
        return deferred.reject err if err
        return deferred.resolve res.body

    deferred.promise.nodeify cb
    return deferred.promise

  fetchEntity: (id, type, cb) ->
    deferred = Q.defer()

    req.get "#{ApiUrl}/entity/#{type}/#{id}"
      .withCredentials()
      .set 'CONNECTX-AUTH', token()
      .end (err, res) ->
        # replace err with res.body.message
        return deferred.reject {id, type}, err if err
        deferred.resolve res.body

    # This allows for both a 'nodeback' and promises
    deferred.promise.nodeify cb
    return deferred.promise

  putEntity: (entity, cb) ->
    deferred = Q.defer()

    req.put "#{ApiUrl}/entity/#{entity.type}/#{entity.id}"
      .withCredentials()
      .set 'CONNECTX-AUTH', token()
      .send entity
      .end (err, res) ->
        return deferred.reject entity, err if err or not res.ok
        deferred.resolve res.body

    deferred.promise.nodeify cb
    return deferred.promise

  searchEntityByName: (type, name, cb) ->
    deferred = Q.defer()

    res.get "#{ApiUrl}/entities/#{type}/#{name}"
      .set 'CONNECTX-AUTH', token()
      .end (err, res) ->
        return deferred.reject(err) if err or not res.ok
        deferred.resolve res.body

    deferred.promise.nodeify(cb)
    return deferred.promise