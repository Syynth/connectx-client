req = require 'superagent'
{ApiUrl} = require 'connectx/config'
{stubs, token} = require './helpers'
_ = require 'lodash'
guid = require 'guid'
Q = require 'q'

querystring = require 'querystring'

module.exports =

  createConnection: (origin, target, attributes, cb) ->
    deferred = Q.defer()
    data = {origin, target, attributes}
    req.post "#{ApiUrl}/connection"
      .withCredentials()
      .set 'CONNECTX-AUTH', token()
      .send data
      .end (err, res) ->
        # replace err with res.body.message
        return deferred.reject("#{err}: #{res.body?.message}") if err or !res.ok
        return deferred.resolve(res.body)

    deferred.promise.nodeify cb
    return deferred.promise

  updateConnection: (origin, target, attributes, cb) ->
    deferred = Q.defer()
    data = {origin, target, attributes}
    req.put "#{ApiUrl}/connection"
      .withCredentials()
      .set 'CONNECTX-AUTH', token()
      .send data
      .end (err, res) ->
        # replace err with res.body.message
        return deferred.reject("#{err}: #{res.body?.message}") if err or !res.ok
        return deferred.resolve(res.body)

    deferred.promise.nodeify cb
    return deferred.promise

  searchConnections: (originType, originId, targetType, targetId, pending, cb) ->
    deferred = Q.defer()
    query = {originType, originId, targetId, targetType, pending}
    for key, val of query when not val?
      delete query[key]
    req.get "#{ApiUrl}/connections?#{querystring.stringify query}"
      .withCredentials()
      .set 'CONNECTX-AUTH', token()
      .end (err, res) ->
        return deferred.reject("#{err}: #{res.body?.message}") if err or !res.ok
        return deferred.resolve(res.body)
    deferred.promise.nodeify cb
    return deferred.promise

  deleteConnection: (origin, target, cb) ->
    deferred = Q.defer()
    data = {origin, target}
    req.del "#{ApiUrl}/connection"
      .withCredentials()
      .set 'CONNECTX-AUTH', token()
      .send data
      .end (err, res) ->
        # replace err with res.body.message
        return deferred.reject("#{err}: #{res.body?.message}") if err or !res.ok
        return deferred.resolve(res.body)
    deferred.promise.nodeify cb
    return deferred.promise
