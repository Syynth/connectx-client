
{EventEmitter} = require 'events'
_ = require 'lodash'
guid = (require 'guid').create().value
ChangeEvent = 'change'
Cache = require 'connectx/cache'
MemCache = require 'connectx/memoryCache'

stores = {}
changeQueued = false

publishChange = ->
  @emit ChangeEvent
  changeQueued = false

defaultValue = (valType) ->
  if valType is String
    return null
  if valType is Number
    return null
  if _.isObject valType
    return defaultObj valType
  if _.isArray valType
    return valType.map (v) -> defaultValue v
  if _.isString(valType) or _.isNumber valType
    return valType

defaultObj = (schema) ->
  res = {}
  unless schema
    return res
  for key, val of schema
    res[key] = defaultValue val
  return res

# TODO: Implement a persistence-free version of these methods
class BaseStore extends EventEmitter
  constructor: (@dispatcher) ->
    @dispatchToken = @dispatcher.register (payload) => @handleDispatch payload
    stores[@storeKey] = @
    @cache = new Cache @read 'cache'
    @queue = new MemCache
  dependents: [] # Define this so it can be set optionally
  commit: ->
    @write 'cache', @cache.data
    @emitChange()
  wipeCache: ->
    @cache = new Cache
    @queue = new MemCache
    @write 'cache', @cache.data
  clearAll: ->
    @cache.clear()
    @commit()
  get: (key) ->
    res = @queue.get key
    return res if res
    @cache.get key
  set: (key, val) ->
    @cache.set key, val
    @commit()
  unset: (key) ->
    @cache.unset key
    @commit()
  # TODO: Find some way to manage querying the queue and cache simultaneously
  query: (pred) -> @cache.query pred
  # TODO: Move read/write implementations to localForage
  read: (key) -> if localStorage[@storeKey + key]? then JSON.parse localStorage[@storeKey + key] else null
  write: (key, value, recurse = false) ->
    try
      localStorage[@storeKey + key] = JSON.stringify value
    catch e
      if e.name is 'QUOTA_EXCEEDED_ERR' # We're using more than 5MB of localStorage
        for key, store of stores
          store.onStorageFull()
          # This might seem silly, but it prevents anything else from preventing a retry
          _.defer (=> @write key, value, guid) unless recurse is guid
  trim: (data) ->
    _.pick _.clone(data), _.keys(@schema)
  defaultInstance: ->
    if @schema then defaultObj @schema else {}
  ensureFields: (data) -> _.extend {}, @defaultInstance(), data
  emitChange: ->
    # This essentially debounces all view re-rendering until the next browser repaint
    if (window.requestAnimationFrame)
      unless changeQueued
        changeQueued = true
        window.requestAnimationFrame publishChange.bind(@)
    else
      publishChange.bind(@)
  addChangeListener: (cb) ->
    @on ChangeEvent, cb
  removeChangeListener: (cb) ->
    @removeListener ChangeEvent, cb
  handleDispatch: (data) -> # TODO: Test this
    @dispatcher.waitFor @dependents.map (store) -> store.dispatchToken
    for handler in @handlers
      if handler.action is data.action.type
        handler.fn.call @, data.action

module.exports = BaseStore
