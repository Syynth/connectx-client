
{EventEmitter} = require 'events'
_ = require 'lodash'
guid = (require 'guid').create()
ChangeEvent = 'change'

stores = {}
changeQueued = false

publishChange = ->
  @emit ChangeEvent
  changeQueued = false

class BaseStore extends EventEmitter
  constructor: (@dispatcher) ->
    @dispatchToken = @dispatcher.register (payload) => @handleDispatch payload
    stores[@storeKey] = @
  dependents: [] # Define this so it can be set optionally
  # TODO: Move read/write implementations to localForage
  read: (key) -> if localStorage[@storeKey + key]? then JSON.parse localStorage[@storeKey + key] else null
  write: (key, value, recurse = false) ->
    try
      localStorage[@storeKey + key] = JSON.stringify value
    catch e
      if e.name is 'QUOTA_EXCEEDED_ERR' # We're using more than 5MB of localStorage
        for key, store of stores
          store.onStorageFull()
          # This might seem silly, but it prevents anything else from preventing a retry
          _.defer (=> @write key, value, guid) unless recurse is guid
  trim: (data) ->
    _.pick _.clone(data), _.keys(@schema)
  emitChange: ->
    unless changeQueued
      changeQueued = true
      window.requestAnimationFrame publishChange.bind(@)
  addChangeListener: (cb) ->
    @on ChangeEvent, cb
  removeChangeListener: (cb) ->
    @removeListener ChangeEvent, cb
  handleDispatch: (data) -> # TODO: Test this
    @dispatcher.waitFor @dependents.map (store) -> store.dispatchToken
    for handler in @handlers
      if handler.source is data.source and handler.type is data.action.type
        handler.fn.call @, data

module.exports = BaseStore
