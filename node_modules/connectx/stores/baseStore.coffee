
{EventEmitter} = require 'events'
_ = require 'lodash'
guid = (require 'guid').create().value
ChangeEvent = 'change'
Cache = require 'connectx/cache'

stores = {}
changeQueued = false

publishChange = ->
  @emit ChangeEvent
  changeQueued = false

# TODO: Implement a persistence-free version of these methods
class BaseStore extends EventEmitter
  constructor: (@dispatcher) ->
    @dispatchToken = @dispatcher.register (payload) => @handleDispatch payload
    stores[@storeKey] = @
    @cache = new Cache @read 'cache'
  dependents: [] # Define this so it can be set optionally
  commit: ->
    @write 'cache', @cache.data
    @emitChange()
  wipeCache: ->
    @cache = new Cache
    @write 'cache', @cache.data
  clearAll: ->
    @cache.clear()
    @commit()
  get: (key) ->
    @cache.get key
  set: (key, val) ->
    @cache.set key, val
    @commit()
  unset: (key) ->
    @cache.unset key
    @commit()
  query: (pred) -> @cache.query pred
  # TODO: Move read/write implementations to localForage
  read: (key) -> if localStorage[@storeKey + key]? then JSON.parse localStorage[@storeKey + key] else null
  write: (key, value, recurse = false) ->
    try
      localStorage[@storeKey + key] = JSON.stringify value
    catch e
      if e.name is 'QUOTA_EXCEEDED_ERR' # We're using more than 5MB of localStorage
        for key, store of stores
          store.onStorageFull()
          # This might seem silly, but it prevents anything else from preventing a retry
          _.defer (=> @write key, value, guid) unless recurse is guid
  trim: (data) ->
    _.pick _.clone(data), _.keys(@schema)
  # This essentially debounces all view re-rendering until the next browser repaint
  emitChange: ->
    unless changeQueued
      changeQueued = true
      window.requestAnimationFrame publishChange.bind(@)
  addChangeListener: (cb) ->
    @on ChangeEvent, cb
  removeChangeListener: (cb) ->
    @removeListener ChangeEvent, cb
  handleDispatch: (data) -> # TODO: Test this
    @dispatcher.waitFor @dependents.map (store) -> store.dispatchToken
    for handler in @handlers
      if handler.action is data.action.type
        handler.fn.call @, data.action

module.exports = BaseStore
