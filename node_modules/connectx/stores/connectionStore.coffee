Dispatcher = require 'connectx/dispatcher'
{SourceType, ActionType} = require 'connectx/config'

BaseStore = require './baseStore'
GroupStore = require './groupStore'
UserStore = require './userStore'
#EventStore = require './eventStore'
#CourseStore = require './courseStore'

etypes = ['user', 'group', 'course', 'event']

getEntityForData = (eData) ->
  if _.isString eData
    entity = {_id: eData}
  else
    entity = eData

getType = (cn) ->
  for etype in etypes
    if cn[etype]
      return etype

getEntityConnections = (action, recurse = true) ->
  cns = action.entity.connections
  id = action.entity.id
  for cn in cns # iterate over connections
    type = getType cn
    entity = getEntityForData cn[type]
    @setConnectionData cn, entity
    unless cn.pending
      oCn = @get entity._id
      @setConnectionData oCn, entity
    ###
    cnData = @get id # get connection data for our entity
    cnData = {} unless cnData? # create default container object for data
    cnData[cn._id] = cn # set connection data by other's key
    @set id, cnData # write our changes back to disk
    unless cn.pending # this is a two way connection, make sure the cache reflects that
      oData = @get cn._id # retrieve other's connection object
      oData = {} unless oData? # create default container object for data
      oData[id] = {} unless oData[id]? # ensure foreign connection to us is available
      oData[id][action.entity.type] = id # make sure my connection type is known i.e. 'user'
      oData[id].pending = false # if we're here, we can't be pending
      @set cn._id, oData # write back to disk
    ###

class ConnectionStore extends BaseStore
  storeKey: 'CONNECTION_STORE'
  getWithId: (entityId, connectionType, entityType) ->
    e = @get entityId
    results = []
    if connectionType is 'strong' or connectionType is 'outbound'
      (results.push data if data[entityType]) for id, data of e when data.pending isnt (connectionType is 'strong')
      return results
    else
      return @query (cn) -> cn[entityId] and cn[entityId].pending
  setConnectionData: (cn, entity) ->
    cnData = @get id
    cnData = {} unless cnData?
    cnData[entity._id] = cn
  dependents: [GroupStore, UserStore]
  isAdmin: (user, entity) ->
    for cnId, cn of (@get entity.id)
      return true if cn.admin && cn.user is user.id
    return false
  handlers: [
    action: ActionType.UserLogin
    fn: getEntityConnections
  ,
    action: ActionType.EntityFetch
    fn: getEntityConnections
  ]

module.exports = new ConnectionStore Dispatcher
