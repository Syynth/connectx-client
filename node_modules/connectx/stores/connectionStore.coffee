Dispatcher = require 'connectx/dispatcher'
{SourceType, ActionType} = require 'connectx/config'
_ = require 'lodash'

BaseStore = require './baseStore'
GroupStore = require './groupStore'
UserStore = require './userStore'
#EventStore = require './eventStore'
#CourseStore = require './courseStore'

stores =
  group: GroupStore
  user: UserStore
  #event: EventStore
  #course: CourseStore

getStore = (type) -> stores[type.toLowerCase()]

# Contains all the mappings from entity to entity
class ConnectionStore extends BaseStore

  storeKey: 'CONNECTION_STORE'

  # depends on all the entity stores
  dependents: [GroupStore, UserStore]

  # just a little syntactix sugar
  _get: (key) -> @cache.get(key) || []

  # takes a connection list and upserts the new connection into the list
  addEdge: (list, edge) ->
    index = _.findIndex list, id: edge.id
    if index is -1
      list.push edge
    else
      list[index] = _.merge {}, list[index], edge

  # records all the connections on a given entity
  recordNode: (node) ->
    node.connections?.map (edge) =>
      @recordEdge node, edge

  # records a single entity/entity connection
  recordEdge: (node, edge) ->
    cns = @_get node.id
    @addEdge cns, edge
    @set node.id, cns
    unless edge.pending
      cns = @_get edge.id
      cn = id: node.id, pending: false, type: node.type
      @addEdge cns, cn
      @set edge.id, cns

  # answers the question: is @user an admin of @entity?
  isAdmin: (user, entity) ->
    @_get(entity.id).filter (cn) -> cn.id is user.id and cn.admin
      .length is 1

  # returns a fully populated array (shallowly) of entities which are connected
  # to an entity with the id of @key
  get: (key, opts = pending: false, all: false) ->
    @_get key
      .filter (cn) -> cn.pending is opts.pending or opts.all
      .map (cn) ->
        getStore cn.type
          .getOrDefault cn.id

  incoming: (key, type) ->
    s = getStore type
    _.compact _.flatten @cache.map (cns, eKey) ->
      cns?.map (cn) ->
        if cn.id is key && s.has(eKey) && cn.pending
          s.getOrDefault eKey
        else
          null
      .filter (e) -> e?

  getByType: (id, type, opts = pending: false, all: false) ->
    @get(id, opts).filter (e) -> e.type is type

  handlers: [
    action: ActionType.UserLogout
    fn: BaseStore::wipeCache
  ,
    action: ActionType.UserLogin
    fn: (action) -> @recordNode action.entity
  ,
    action: ActionType.EntityFetch
    fn: (action) -> @recordNode action.entity
  ,
    action: ActionType.EntitySearch
    fn: (action) ->
      action.entities.map (e) => @recordNode e
  ,
    action: ActionType.ConnectionCreated
    fn: (action) -> @recordEdge action.from,
      id: action.to.id
      type: action.to.type
      pending: action.pending
  ]

module.exports = new ConnectionStore Dispatcher
