Dispatcher = require 'connectx/dispatcher'
{SourceType, ActionType} = require 'connectx/constants'

BaseStore = require './baseStore'

getEntityConnections = (action) ->
  cns = action.entity.connections
  id = action.entity.id
  # iterate over connections
  for cn in cns
    cnData = @get id # get connection data for our entity
    cnData = {} unless cnData? # create default container object for data
    cnData[cn._id] = cn # set connection data by other's key
    @set id, cnData # write our changes back to disk
    unless cn.pending # this is a two way connection, make sure the cache reflects that
      oData = @get cn._id # retrieve other's connection object
      oData = {} unless oData? # create default container object for data
      oData[id] = {} unless oData[id]? # ensure foreign connection to us is available
      oData[id][action.entity.type] = id # make sure my connection type is known i.e. 'user'
      oData[id].pending = false # if we're here, we can't be pending
      @set cn._id, oData # write back to disk

class ConnectionStore extends BaseStore
  storeKey: 'CONNECTION_STORE'
  getWithId: (entityId, connectionType, entityType) ->
    e = @get entityId
    results = []
    if connectionType is 'strong' or connectionType is 'outbound'
      (results.push data if data[entityType]) for id, data of e when data.pending isnt (connectionType is 'strong')
      return results
    else
      return @query (cn) -> cn[entityId] and cn[entityId].pending

  isAdmin: (user, entity) ->
    for cnId, cn of (@get entity.id)
      return true if cn.admin && cn.user is user.id
    return false
  handlers: [
    action: ActionType.UserLogin
    fn: getEntityConnections
  ,
    action: ActionType.EntityFetch
    fn: getEntityConnections
  ]

module.exports = new ConnectionStore Dispatcher
