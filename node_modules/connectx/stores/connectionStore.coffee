Dispatcher = require 'connectx/dispatcher'
{SourceType, ActionType} = require 'connectx/config'
_ = require 'lodash'

BaseStore = require './baseStore'
GroupStore = require './groupStore'
UserStore = require './userStore'
#EventStore = require './eventStore'
#CourseStore = require './courseStore'

etypes = ['user', 'group', 'course', 'event']

getEntityForData = (eData, type) ->
  if _.isString eData
    entity = {_id: eData, type: type, id: eData}
  else
    entity = eData
    entity.type = type
    entity.id = entity.id ? entity._id
  return entity

getType = (cn) ->
  for etype in etypes
    if cn[etype]
      return etype

isAdminOf = (entity, admin) ->
  unless entity.connections
    return false
  cns = _.filter entity.connections, (c) -> c[admin.type]?
  return cns[0].admin

getEntityConnections = (action) ->
  cns = action.entity.connections
  id = action.entity.id
  for cn in cns # iterate over connections
    type = getType cn
    entity = getEntityForData cn[type], type
    @setConnectionData id, cn, entity
    unless cn.pending
      oCn = {pending: false, admin: isAdminOf(entity, action.entity)}
      @setConnectionData entity.id, oCn, action.entity

handleClientRequest = (action) ->
  cnData = @get(action.from.id) || {}
  cn = {}
  cn[action.to.type] = action.to
  cn.pending = true
  cn.clientId = action.clientId
  cnData[action.to.id] = cn
  @queue.set action.from.id, cnData

cnError = -> new Error 'Unable to match connection creations server response to originating client request.'
recordRequest = (action) ->
  # get safe copy of data for origin entity
  cnData = _.clone @get(action.from.id)
  # get connection to target entity
  cn = cnData[action.to.id]
  # assert connection has client Id
  unless cn.clientId is action.clientId then throw cnError()
  # remove unneeded clientId
  delete cn.cleintId
  # retrieve verified copy of origin's data
  cacheData = @cache.get(action.from.id) || {}
  # update verified data
  cacheData[action.to.id] = cn
  # write changes to disk
  @set action.from.id, cacheData
  # remove connection from pending queue
  delete cnData[action.to.id]
  # update the pending queue
  if _.isEmpty cnData
    # delete the item from the queue if it has no remaining requests pending
    @queue.unset action.from.id
  else
    # update the item if it has some remaining work to do
    @queue.set action.from.id, cnData

class ConnectionStore extends BaseStore
  storeKey: 'CONNECTION_STORE'
  schema:
    pending: Boolean
    admin: Boolean
  get: (key) ->
    _.merge {}, @cache.get(key), @queue.get(key)
  getWithId: (entityId, connectionType, entityType) ->
    e = @get entityId
    results = []
    if connectionType is 'strong' or connectionType is 'outbound'
      (results.push data if data[entityType]) for id, data of e when data.pending isnt (connectionType is 'strong')
      return results
    else
      return @query (cn) -> cn[entityId] and cn[entityId].pending
  setConnectionData: (id, cn, entity) ->
    cnData = @get id
    cnData = {} unless cnData?
    cn[entity.type] = entity
    cnData[entity.id] = cn
    @set id, cnData
  dependents: [GroupStore, UserStore]
  isAdmin: (user, entity) ->
    for cnId, cn of (@get entity.id)
      return true if cn.admin && cn.user.id is user.id
    return false
  handlers: [
    action: ActionType.UserLogin
    fn: getEntityConnections
  ,
    action: ActionType.EntityFetch
    fn: getEntityConnections
  ,
    action: ActionType.ConnectionSentClient
    fn: handleClientRequest
  ,
    action: ActionType.ConnectionCreated
    fn: recordRequest
  ]

module.exports = new ConnectionStore Dispatcher
