_ = require 'lodash'
{EventEmitter} = require 'events'

{SourceType, ActionType} = require 'connectx/constants'
Dispatcher = require 'connectx/dispatcher'
Cache = require 'connectx/cache'

BaseStore = require './baseStore'

p = new Cache

getKeyForAction = (action) -> action.post.id || action.clientId
getKeyForPost = (post) -> post.id || post.clientId

markPostFailed = (action) ->
  post = p.get action.clientId
  post.failed = true
  post.pending = false
  @commit()

migratePostToServerId = (action) ->
  oldId = action.clientId
  newId = action.serverId
  post = p.get oldId
  delete post.clientId
  post.id = newId
  post.pending = false
  post.getId = -> getKeyForPost post
  delete post.failed
  p.unset oldId
  p.set newId, post
  @commit()

markPending = (action) ->
  post = p.get action.clientId
  post.pending = true
  post.failed = false
  p.set action.clientId, post
  @commit()

removePost = (action) ->
  p.unset getKeyForAction action
  @commit()

removeAllPosts = ->
  p.clear()
  @commit()

wipeCache = ->
  p = new Cache
  @write 'postCache', p.data

addPosts = (data) ->
  for postData in data.posts
    do (postData) ->
      post = _.clone postData
      unless post.id
        post.clientId = data.clientId
        post.pending = true
        delete post.file # remove base64 - otherwise 5mb will be too small!
      post.getId = -> getKeyForPost post
      p.set post.getId(), post
      delete post.comments
  @commit()

class PostStore extends BaseStore
  constructor: (dispatcher) ->
    super dispatcher
    data = @read 'postCache'
    ###
    # TODO: After localForage
    data = @read 'postCache', =>
      for id, post of data
        do (post) -> data[id].getId = -> getKeyForPost post
      p = new Cache data
      @commit()
    ###
    for id, post of data
      do (post) -> data[id].getId = -> getKeyForPost post
    p = new Cache data
  storeKey: 'POST_STORE'
  schema:
    author: Object
    owner: Object
    text: String
    createdAt: Date
    file: String
  write: (key, data) ->
    posts = {}
    for id, post of data when !post.failed and !post.pending
      posts[id] = post
    super key, posts
  onStorageFull: -> removeAllPosts()
  getFailed: -> p.query (post) -> post.failed
  getById: (id) -> p.query (post) -> p.getId() is id
  getByAuthorId: (id) -> p.query (post) -> post.author.id is id
  getByOwnerId: (id) -> p.query (post) -> post.owner.id is id
  commit: ->
    @emitChange()
    @write 'postCache', p.data
  handlers: [
    action: ActionType.CreatePost
    fn: addPosts
  ,
    action: ActionType.RemovePost
    fn: removePost
  ,
    action: ActionType.PostResent
    fn: markPending
  ,
    action: ActionType.UserLogout
    fn: wipeCache
  ,
    action: ActionType.PostSaved
    fn: migratePostToServerId
  ,
    action: ActionType.PostCreationFailed
    fn: markPostFailed
  ,
    action: ActionType.PostCollectionSync
    fn: addPosts
  ]

module.exports = new PostStore Dispatcher
