
###
PostStore should:
+ store posts by id/clientId
+ query posts by author
+ query posts by owner
+ persist posts to disk
- support pagination (later)
+ switch from clientId to serverId after a post has been saved
+ clear cache/disk when user logs out
+ mark posts as failed when requests fail
+ support POST retries
###

{EventEmitter} = require 'events'
Dispatcher = require 'connectx/dispatcher'
{SourceType, ActionType} = require 'connectx/constants'
_ = require 'lodash'
Cache = require 'connectx/cache'

BaseStore = require './baseStore'

p = new Cache

getKeyForAction = (action) -> action.post.id || action.clientId
getKeyForPost = (post) -> post.id || post.clientId

markPostFailed = (clientId, self) ->
  post = p.get clientId
  post.failed = true
  post.pending = false
  self.write 'postCache', p.data
  self.emitChange()

migratePostToServerId = (oldId, newId, self) ->
  post = p.get oldId
  delete post.clientId
  post.id = newId
  post.pending = false
  post.getId = -> getKeyForPost post
  delete post.failed
  p.unset oldId
  p.set newId, post
  self.write 'postCache', p.data
  self.emitChange()

markPending = (id, self) ->
  post = p.get id
  post.pending = true
  p.set id, post
  self.write 'postCache', p.data
  self.emitChange()

removePost = (action, self) ->
  p.unset getKeyForAction action
  self.emitChange()
  self.write 'postCache', p.data

removeAllPosts = (self) ->
  p.clear()
  self.emitChange()
  self.write 'postCache', p.data

addPosts = (data, self) ->
  for postData in data.posts
    do (postData) ->
      post = _.clone postData
      unless post.id
        post.clientId = data.clientId
        post.pending = true
        delete post.file # remove base64 - otherwise 5mb will be too small!
      post.getId = -> getKeyForPost post
      p.set post.getId(), post
  self.emitChange()
  self.write 'postCache', p.data

class PostStore extends BaseStore
  constructor: (dispatcher) ->
    super dispatcher
    data = @read 'postCache'
    for id, post of data
      do (post) -> data[id].getId = -> getKeyForPost post
    p = new Cache data

  storeKey: 'POST_STORE'
  schema:
    author: Object
    owner: Object
    text: String
    createdAt: Date
    file: String
  write: (key, data) ->
    posts = {}
    for id, post of data when !post.failed and !post.pending
      posts[id] = post
    super key, posts

  onStorageFull: -> removeAllPosts()
  getFailed: -> p.query (post) -> post.failed
  getById: (id) -> p.query (post) -> p.getId() is id
  getByAuthorId: (id) -> p.query (post) -> post.author.id is id
  getByOwnerId: (id) -> p.query (post) -> post.owner.id is id
  handlers: [
    source: SourceType.Client
    type: ActionType.CreatePost
    fn: (payload) -> addPosts payload.action, @
  ,
    source: SourceType.Client
    type: ActionType.RemovePost
    fn: (payload) -> removePost payload.action, @
  ,
    source: SourceType.Client
    type: ActionType.PostResent
    fn: (payload) -> markPending payload.action.clientId, @
  ,
    source: SourceType.Client
    type: ActionType.UserLogout
    fn: (payload) -> p = new Cache
  ,
    source: SourceType.Server
    type: ActionType.PostSaved
    fn: (payload) ->
      migratePostToServerId payload.action.clientId, payload.action.serverId, @
  ,
    source: SourceType.Server
    type: ActionType.PostCreationFailed
    fn: (payload) -> markPostFailed payload.action.clientId, @
  ,
    source: SourceType.Server
    type: ActionType.PostCollectionSync
    fn: (payload) -> addPosts payload.action, @
  ]

module.exports = new PostStore Dispatcher
