
###
CommentStore should:
+ store comments by id/clientId
+ query comments by post
+ persist comments to disk
- support pagination (later)
+ switch from clientId to serverId after a post has been saved
+ clear cache/disk when user logs out
+ mark posts as comment when requests fail
+ support POST retries
###

{EventEmitter} = require 'events'
Dispatcher = require 'connectx/dispatcher'
{SourceType, ActionType} = require 'connectx/constants'
_ = require 'lodash'
Cache = require 'connectx/cache'

BaseStore = require './baseStore'

p = new Cache

getKeyForAction = (action) -> action.comment.id || action.clientId
getKeyForComment = (comment) -> comment.id || comment.clientId

markCommentFailed = (clientId, self) ->
  comment = p.get clientId
  comment.failed = true
  comment.pending = false
  self.write 'commentCache', p.data
  self.emitChange()

migrateCommentToServerId = (oldId, newId, self) ->
  comment = p.get oldId
  delete comment.clientId
  comment.id = newId
  comment.pending = false
  comment.getId = -> getKeyForComment comment
  delete comment.failed
  p.unset oldId
  p.set newId, comment
  self.write 'commentCache', p.data
  self.emitChange()

markPending = (id, self) ->
  comment = p.get id
  comment.pending = true
  comment.failed = false
  p.set id, comment
  self.write 'commentCache', p.data
  self.emitChange()

removeComment = (action, self) ->
  p.unset getKeyForAction action
  self.emitChange()
  self.write 'commentCache', p.data

removeAllComments = (self) ->
  p.clear()
  self.emitChange()
  self.write 'commentCache', p.data

addComments = (data, self) ->
  for commentData in data.comments
    do (commentData) ->
      comment = _.clone commentData
      unless comment.id
        comment.clientId = data.clientId
        comment.pending = true
      comment.getId = -> getKeyForComment comment
      p.set comment.getId(), comment
  self.emitChange()
  self.write 'commentCache', p.data

class CommentStore extends BaseStore
  constructor: (dispatcher) ->
    super dispatcher
    data = @read 'commentCache'
    for id, comment of data
      do (comment) -> data[id].getId = -> getKeyForComment comment
    p = new Cache data

  storeKey: 'COMMENT_STORE'
  schema:
    author: Object
    text: String
    createdAt: Date
  write: (key, data) ->
    comments = {}
    for id, comment of data when !comment.failed and !comment.pending
      comments[id] = comment
    super key, comments

  onStorageFull: -> removeAllComments()
  getFailed: -> p.query (comment) -> comment.failed
  getAll: -> p.data
  getById: (id) -> (p.query (comment) -> comment.getId() is id)[0]
  handlers: [
    source: SourceType.Client
    type: ActionType.CommentCreate
    fn: (payload) -> addComments payload.action, @
  ,
    source: SourceType.Client
    type: ActionType.RemoveComment
    fn: (payload) -> removeComment payload.action, @
  ,
    source: SourceType.Client
    type: ActionType.CommentResent
    fn: (payload) -> markPending payload.action.clientId, @
  ,
    source: SourceType.Client
    type: ActionType.UserLogout
    fn: (payload) ->
      p = new Cache
      @write 'commentCache', p.data
  ,
    source: SourceType.Server
    type: ActionType.CommentSaved
    fn: (payload) ->
      migrateCommentToServerId payload.action.clientId, payload.action.serverId, @
  ,
    source: SourceType.Server
    type: ActionType.CommentCreationFailed
    fn: (payload) -> markCommentFailed payload.action.clientId, @
  ,
    source: SourceType.Server
    type: ActionType.PostCollectionSync
    fn: (payload) -> addCommentsForPosts payload.action, @
  ]

module.exports = new CommentStore Dispatcher
