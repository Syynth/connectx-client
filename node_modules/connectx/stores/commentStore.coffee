_ = require 'lodash'
{EventEmitter} = require 'events'

{SourceType, ActionType} = require 'connectx/constants'
Dispatcher = require 'connectx/dispatcher'
Cache = require 'connectx/cache'

BaseStore = require './baseStore'

p = new Cache

getKeyForAction = (action) -> action.comment.id || action.clientId
getKeyForComment = (comment) -> comment.id || comment.clientId

markCommentFailed = (action) ->
  comment = p.get action.clientId
  comment.failed = true
  comment.pending = false
  @commit()

migrateCommentToServerId = (action) ->
  oldId = action.clientId
  newId = action.serverId
  comment = p.get oldId
  delete comment.clientId
  comment.id = newId
  comment.pending = false
  comment.getId = -> getKeyForComment comment
  delete comment.failed
  p.unset oldId
  p.set newId, comment
  @commit()

markPending = (action) ->
  comment = p.get action.clientId
  comment.pending = true
  comment.failed = false
  p.set action.clientId, comment
  @commit()

removeComment = (action) ->
  p.unset getKeyForAction action
  @commit()

removeAllComments = ->
  p.clear()
  @commit()

wipeCache = ->
  p = new Cache
  @write 'commentCache', p.data

addComments = (data) ->
  for commentData in data.comments
    do (commentData) ->
      comment = _.clone commentData
      unless comment.id
        comment.clientId = data.clientId
        comment.pending = true
      comment.getId = -> getKeyForComment comment
      comment.postId = data.postId
      p.set comment.getId(), comment
  @commit()

addCommentsForPosts = (action) ->

class CommentStore extends BaseStore
  constructor: (dispatcher) ->
    super dispatcher
    data = @read 'commentCache'
    for id, comment of data
      do (comment) -> data[id].getId = -> getKeyForComment comment
    p = new Cache data

  storeKey: 'COMMENT_STORE'
  schema:
    author: Object
    text: String
    createdAt: Date
  write: (key, data) ->
    comments = {}
    for id, comment of data when !comment.failed and !comment.pending
      comments[id] = comment
    super key, comments

  onStorageFull: -> removeAllComments()
  getFailed: -> p.query (comment) -> comment.failed
  getById: (id) -> (p.query (comment) -> comment.getId() is id)[0]
  getCommentsForPost: (postId) -> p.query (comment) -> comment.postId is postId
  commit: ->
    @emitChange()
    @write 'commentCache', p.data
  handlers: [
    action: ActionType.CommentCreate
    fn: addComments
  ,
    action: ActionType.CommentDelete
    fn: removeComment
  ,
    action: ActionType.CommentResent
    fn: markPending
  ,
    action: ActionType.UserLogout
    fn: wipeCache
  ,
    action: ActionType.CommentSaved
    fn: migrateCommentToServerId
  ,
    action: ActionType.CommentCreationFailed
    fn: markCommentFailed
  ,
    type: ActionType.PostCollectionSync
    fn: addCommentsForPosts
  ]

module.exports = new CommentStore Dispatcher
