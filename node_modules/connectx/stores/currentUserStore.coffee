Dispatcher = require 'connectx/dispatcher'
{SourceType, ActionType} = require 'connectx/config'

BaseStore = require './baseStore'

class CurrentUserStore extends BaseStore
  storeKey: 'CURRENT_USER'
  schema:
    id: String
    description: String
    email: String
    images: [String]
    name: String
    password: String
    salt: String
    token: String
    verificationId: String
    location:
      address: String
      city: String
      state: String
      zip: String
      note: String
  isLoggedIn: -> BaseStore::get.call(@, 'currentUser')?
  getCurrentUser: ->
    return null if !@isLoggedIn()
    res = @queue.get 'currentUser'
    return res if res
    @ensureFields @get 'currentUser'
  getCurrentActor: ->
    return null if !@isLoggedIn()
    res = @queue.get 'currentActor'
    return res if res
    @get 'currentActor'
  wipeCache: ->
    super()
    @commit()
    localStorage.clear()
  #set: (key, val) ->
  #  super key, @ensureFields val
  get: (key) ->
    @ensureFields super key
  handlers: [
    action: ActionType.UserLogin
    fn: (action) ->
      @set 'currentUser', action.user
      @set 'currentActor', action.user
  ,
    action: ActionType.EntityLogin
    fn: (action) ->
      @cache.set 'currentActor', action.entity
      @commit()
  ,
    action: ActionType.UserUpdateClient
    fn: (action) ->
      @queue.set 'currentUser', action.user
      @emitChange()
  ,
    action: ActionType.EntityFetch
    fn: (action) ->
      usr = action.entity
      if usr.id is @getCurrentUser().id
        usr.token ?= @getCurrentUser().token
        @set 'currentUser', usr
      if usr.id is @getCurrentActor().id
        @set 'currentActor', usr
  ,
    action: ActionType.UserUpdate
    fn: (action) ->
      @queue.unset 'currentUser'
      @set 'currentUser', action.user
  ,
    action: ActionType.UserLogout
    fn: CurrentUserStore::wipeCache
  ]

module.exports = new CurrentUserStore Dispatcher
