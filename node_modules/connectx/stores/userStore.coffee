_ = require 'lodash'
{EventEmitter} = require 'events'

{SourceType, ActionType} = require 'connectx/config'
Dispatcher = require 'connectx/dispatcher'
Cache = require 'connectx/cache'

BaseStore = require './baseStore'

recordEntity = (action) ->
  return if action.entity.type isnt 'user'
  recordUser.call @, action.entity

recordUser = (user) -> @set user.id, @ensureFields user

class UserStore extends BaseStore
  storeKey: 'USER_STORE'
  schema:
    id: String
    type: 'user'
    email: String
    password: String
    token: String
    salt: String
    verificationId: String
    name: String
    privacy: String
    description: String
    connections: [Object]
    location:
      address: String
      city: String
      state: String
      zip: String
      note: String
    profileImage: String
    coverImage: String
    images: [String]
  constructor: (dispatcher) ->
    super dispatcher
    p = new Cache @read 'cache'
  set: (key, val) -> super key, @ensureFields val
  getOrDefault: (id) ->
    res = @get(id) || {id: id}
    @ensureFields res
  onStorageFull: -> @clearAll()
  handlers: [
    action: ActionType.UserLogin
    fn: recordEntity
  ,
    action: ActionType.UserLogout
    fn: BaseStore::wipeCache
  ,
    action: ActionType.EntityFetch
    fn: recordEntity
  ,
    action: ActionType.EntitySearch
    fn: (action) ->
      if action.entityType is 'user'
        action.entities.map (e) =>
          recordUser.call @, e

  ]

module.exports = new UserStore Dispatcher
